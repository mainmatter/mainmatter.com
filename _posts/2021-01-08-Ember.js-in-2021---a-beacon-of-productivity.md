---
title: 'Ember.js in 2021 â€“ a beacon of productivity'
author: 'Marco Otte-Witte'
github: marcoow
twitter: marcoow
topic: ember
bio: 'Founder and Managing Director of simplabs'
description:
  'Marco Otte-Witte makes the case for Ember in 2021 and explains why he
  considers the framework a beacon of productivity in the middle of a roaring
  sea of complexity'
og:
  image: /assets/images/posts/2020-12-29-built-to-last-2-joel-kelly/og-image.png
---

Ember has been around since the early days of the frontend renaissance that
already started several years ago by now. It's almost a decade old and dates
back well before React, Vue, Svelte and all the others were released. The
framework has never been on the forefront of the frontend hype train but quietly
enabled teams to ship steadily and sustainably â€“ among them
[Qonto](https://qonto.com) and [Clark](https://clark.de), two of Europe's
[Top 50 FinTechs](https://thefintech50.com/the-fintech50-2020) in 2020.

In this post I want to make the case for Ember in 2021 and explain why I
consider it a beacon of productivity in the middle of a roaring sea of
complexity. While everyone is obsessed with change and innovation (in many cases
mistaking the former for the latter), Ember allows teams to excel at executing
their product vision and focus on shipping instead of getting lost in low-level
rabbit holes where little value is to be generated for users.

<!--break-->

To be completely transparent, I'm heavily biased towards Ember. With simplabs, I
founded what is now the leading Ember consultancy in Europe. We've helped many
teams successfully build, evolve and maintain large applications with Ember over
the years. Some of our team members are involved in the Ember core team and we
maintain a number of widely adopted libraries in the ecosystem and are one of
the official sponsors of the framework even. With all that experience and some
experience with teams using other technology stacks, I think we do have a view
on frontend development that's maybe a bit different from other teams' views and
because of that it is worth sharing.

## The Status Quo of Frontend Engineering

There has been a huge amount of progress in the frontend engineering world over
the past 10 years or so. Back when Ember was first released, jQuery (and
sometimes even Prototype) were still the go-to solutions for making otherwise
static and server rendered pages dynamic. And while jQuery remains
[the most used JavaScript library on the web to date](https://w3techs.com/technologies/history_overview/javascript_library/all/q),
techniques introduced first by Ember and Angular.js (and later React and others)
are now widely accepted and adopted. While frontend engineering was something
that many _"real"_ developers would look down on only a few years ago and that
was often merely an afterthought, the field has been professionalized
significantly and now gets the attention it deserves. That does not only
acknowledge the fact that it is a hugely complex field (and in many aspects more
challenging than backend development) but also its significance due to the
direct impact on the end user's experience.

<blockquote class="tweet"><p lang="en" dir="ltr">Front end software development is:<br><br>- real-time (instant load, 60fps)<br>- distributed, incremental (synchronize remote data as needed)<br>- asynchronous<br>- reactive (react to user actions in realtime)<br><br>Front end is the hardest kind of dev I do. The folks who do it every day are heroes.</p>&mdash; Yehuda Katz #BlackLivesMatter (@wycats) <a href="https://twitter.com/wycats/status/930463710941872128?ref_src=twsrc%5Etfw">November 14, 2017</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

Things haven't slowed down in the world of frontend development though. In fact,
quite the opposite â€“ we are seeing innovation and change at an extremely high
and seemingly still accelerating pace. JavaScript has become the
[world's dominant language](https://insights.stackoverflow.com/survey/2020#technology-programming-scripting-and-markup-languages)
and is the default answer many developers have to just about anything they might
be dealing with on the web
([some people are even writing their CSS in JS now ðŸ™€](https://en.wikipedia.org/wiki/CSS-in-JS)).
And while innovation and exploring possibilities and new approaches are all
great, the fact that a huge community of developers is collectively on the
lookout for the next big thing and everyone is only waiting to jump on the next
bandwagon does more harm than people might see. It's easy to underestimate the
level of churn that adopting new approaches over-eagerly brings, only to realize
later the hype train has changed direction again and what you bet on has now
turned into a dead-end.

## The Complexity Fetish

I do think that complexity is fetishized in the frontend world â€“ mainly due to
two sentiments. One is simply ego. As the virologists and epidemiologist say
(and we all have learned in the past year), "There's no glory in prevention".
And just like that there's little glory to be found in steadily shipping real
product value based on solutions to common problems others have found before you
and encoded in frameworks based on strong conventions. But there's all the
engineering glory to be found in figuring out the bestâ„¢ way to address a
particular problem and taming low level complexity even if all that work is not
contributing to executing on a product and company vision â€“ taking on such
problems is often done for the glory alone, regardless of whether the problem
has been solved before or even poses a challenge in the respective project at
all.

[Chris Manson](https://simplabs.com/blog/author/real_ate) from the simplabs (and
[Ember Learning Core](https://emberjs.com/teams/)) team told me the story of an
engineer he was talking to at a conference. They understood and completely
agreed with the value that Ember provided as a full-featured, batteries included
frontend application framework that enables teams to build skyscrapers starting
from the 20th floor instead of beginning with laying the foundation. Yet they
said, they would never propose the framework to their boss because then they
wouldn't get to write as much code because _"Ember does it all for you"_. While
that **can** be a valid reason not to choose a technical solution at times, in
most cases shipping **is** important and should be the main driver for the
decision.

The other sentiment that I believe contributes to the complexity fetish is a
desire to be in control of ever every single aspect and detail of one's app.
That might be driven partly by the Node community's â€“ highly questionable in my
opinion â€“ love relationship with micro packages where applications are made up
of a carefully assembled combination of tiny libraries that perfectly cater to a
particular application's very special needs â€“ or in most cases, the personal
preferences of the engineer(s) setting up the project.

I think there's also another, historical reason that plays into this to some
extent. In the earlier days of JavaScript, one indeed was in full control about
everything since most client-side code in most apps was a combination of
handwritten snippets and handpicked scripts and widgets where everyone had their
own ways of organizing code bases. Even as apps work differently now, a bit of
that sentiment of needing to have full control just like in the old days seems
to have made it over. Many teams I've seen have strongly held opinions about
what particular routing library they need, why they cannot use the state
management patterns of framework X but have to use a different micro-library
etc. And while many of these arguments will make sense from a purely technical
point of view, the practical impact is more often than not neglectable or
irrelevant even. For sure, all the time and effort spent on assembling (and then
maintaining) these highly customized ad-hoc frameworks is **not** going into
building and improving real products for real users.

## Ember: Turning Complexity into Simplicity

Contrary to that, Ember takes these low level and mostly unimportant
[bike-shedding](https://en.wikipedia.org/wiki/Law_of_triviality) decisions out
of the hands of developers. It is a full-featured, batteries-included framework
and like similar solutions on the backend side like Ruby on Rails (that it also
shares some core values with), it provides everything one needs to build an app
in a coherent package with a consistent API where the individual parts all work
together seamlessly since they were meant to work together from the beginning.
Because of that, it doesn't allow the level of freedom and fine grained control
over every little detail that many are looking for in the frontend world. And
while that sounds unappealing to many as explained above, it's actually its
biggest strength as it allows teams to focus on executing on their product and
company vision and shipping real value for their users.

### Essential vs. accidental complexity

Writing any software system means dealing with a large amount of complexity.
That complexity comes in two forms (see
[Fred Brooks' famous book on the topic](https://en.wikipedia.org/wiki/No_Silver_Bullet)):
essential complexity and accidental complexity. Essential complexity is how hard
something is to do, regardless of one's experience, technology used etc. It's a
property of the problem you're solving, e.g. adding two numbers is generally
easy while building a social network is hard in comparison. On the other hand,
accidental complexity is the part of the complexity that is not inherent to the
problem one is solving but introduced as part of the solution. Adding two
numbers in C++ is more complex than doing the same thing in JavaScript, as in
C++ you have to worry about memory management, you have to compile etc. â€“ all of
that isn't necessary in (vanilla) JavaScript which thus leads to less accidental
complexity.

Frameworks like Ember are all about reducing the amount of accidental complexity
that the developers have to deal with. Since Ember takes care of all or the vast
majority of aspects of the application that are not an essential part of the
particular problem domain (e.g. routing, data loading etc.), it takes all of the
accidental complexity associated with these aspects out of the hands of the
developers. They instead can focus on the essential complexity only. Clearly
separating the aspects the developer is in control of from everything else could
be seen as a [liberating constraint](https://wiki.c2.com/?LiberatingConstraint)
â€“ by constraining control over non-essential aspects, it liberates developers
from doing just that and enables them to spend their time and effort where they
truly add value. In contrast to that, building on micro packages and aiming for
fine grained control over all of an application's aspects will necessarily
resurface all the accidental complexity associated with those and put the
responsibility for them back into the hands of developers. They now have to deal
with webpack configurations, integration between packages etc. All effort and
time spent on these tasks is not going into delivering product value for real
users.

At simplabs, we have seen many teams struggling with all kinds of problems and
helped them solve those. We have rarely seen cases where frameworks like Ember
or Rails caused problems due to the way they handle the non-essential aspects of
applications. Most of the time what leads to problems is teams struggling to
organize code in a maintainable and extensible way in areas where frameworks
leave freedom and do not provide strong conventions (typical examples being
shaping and orchestrating components in Ember or organizing business logic in
Rails apps) â€“ in fact, the worst kinds of problems typically arise where teams
build their own extensions to frameworks that add large amounts of accidental
complexity and add more problems than they solve (I have seen at least eight
different approaches to organizing business logic in custom constructs in Rails
apps and every single one eventually lead to a dead end).

## Stability without Stagnation

The fact that Ember hides most of the accidental complexity and takes control
over these aspects of applications doesn't mean nothing can ever change in the
framework and no progress can be had. There is steady progress in the framework
but Ember shields developer from having to deal with the involved churn as much
as possible. Instead, Ember constantly ships improvements in backwards
compatible minor releases with clear upgrade paths, following its
[release strategy](https://emberjs.com/releases). That allow teams to keep up
with recent developments and benefit from innovation in the frontend field while
minimizing the incurred cost. All changes to Ember itself go through the
[RFC process](https://github.com/emberjs/rfcs), are validated and tested in real
apps through the canary and beta releases before being rolled out to the
community. Once that happens the previous APIs will remain available but be
deprecated along with extensive documentation for migrating to the new paradigms
(and often there are codemods even for automating the task; there's also
[a dedicated app](https://upgrade.emberjs.com) listing the changes between two
versions and the changes necessary for upgrading). So instead of every single
team paying the cost for exploration and experimentation, the framework and
community pay that cost once for the entire community to benefit afterwards.
That's what the Ember community also refers to as the
[safety of the herd](https://embermap.com/notes/62-safety-of-the-herd).

And Ember has seen many substantial changes to its core concepts over the years:

- moving away from the `Ember` global to ES2015 modules
- introducing a completely new component API
- replacing the core rendering engine of the framework (resulting in Glimmer VM
  which is probably the most advanced rendering pipeline available)
- removing the custom object model and adopting native classes

Each of those changes were substantial updates to the Ember programming model.
Yet, each one was released in a way that made it easy for the entire community
to follow along. The entire ecosystem revolving around one defined set of
techniques and practices while making sure no project is left behind, stuck on
old patterns prevents fragmentation. Everyone in the community has a collective
interest in supporting, maintaining and evolving the same set of tools and will
collectively make sure those continue to work and work well for everyone using
Ember. There is no risk on individual teams and projects being left on their own
because they bet on the wrong horse that ends up not being actively maintained
so that the teams would either have to take over maintenance themselves or
switch to a different solution which would often result in large refactorings,
again directing time and effort into dealing with accidental complexity rather
than essential complexity and generating product value.

## The right tool for the right job

As laid out above, Ember is a full featured application framework that contains
coherent building blocks and concepts for all aspects that real world
applications face and that are not inherently coupled to their problem domain.
While Ember hides most of the internals of these concepts so developers do not
have to deal with them, all these concepts are still present and contribute to
the framework's public API and general architecture that one is exposed to when
working on an Ember project. This often leads to criticism focussed on the fact
that there is a lot to learn with Ember and some or much of that might not be
necessary for a particular project

> I just want to build a calculator widget for my static site â€“ why do I need to
> worry about routing, error states, etc. for that?
>
> â€“ someone who should have chosen React

Comments like that are hard to counter. Of course there's no good reason why
someone should be forced to add a route structure, organize templates in
hierarchies and understand what initializers are when the application they are
building does not need any of that anyway. In reality though, this doesn't imply
Ember is overly complex but the person turned to the wrong tool for the
particular job.

Most web projects fall into one of three categories:

- completely or mostly static sites, e.g. your favorite news outlet's site
- dynamic widgets (components) to be used in larger applications or on static
  sites, e.g. the [Intercom](https://www.intercom.com) widget (Intercom are a
  long-time Ember user for their dashboard app)
- full-on web apps that resemble what was only possible in native desktop apps
  until relatively recently, e.g. Gmail or an online banking dashboard like the
  one [Qonto](https://qonto.com) (another successful Ember user) are building

These kinds of apps are all different and have very different characteristics
and requirements in terms of interactivity, (load time) performance and user
expectations. Ember as an application framework is really made for the last kind
of project in the above list â€“ full-on web applications. There are plenty of
other and better options for the other two (and for static sites, I'd argue any
client-side framework is the wrong choice more often than not anyway â€“ however,
admittedly we went through the
[excercise of completely over-engineering a static site](https://simplabs.com/blog/2020/01/31/how-to-over-engineer-a-static-page/)
as well). **If you're not building a web application, don't look at a web
application framework for a solution.** Yet, many teams would do that and then
be disappointed that the framework they tried does not turn out to be a great
fit. To me that's a bit like complaining SpaceX's rockets aren't great to do
grocery shopping with. Yes, you might be able to eventually fly the rocket to
the local shop and back to your home but it's not going to be the most effective
way to tackle that task maybe â€“ still, that doesn't mean it's a bad rocket,
maybe a cargo bike would have been the better choice for the task from the
beginning.

## A productive future with Ember

Ember has never been the coolest kid on the block and probably never will be.
Building on solutions others have found before you isn't a particularly
attractive outlook for many developers. It takes quite a bit of experience and
reflection to let go of a bit of vanity and accept that the less you have to do
yourself and the more you can build on existing, proven solutions, the better it
is in the interest of the company you build or work for which is ultimately
what's paying the bills and salaries. Ember developers
[frequently are the highest paid and most senior in the annual state of JS survey](https://2019.stateofjs.com/front-end-frameworks/#front_end_frameworks_salary_heatmap)
and I don't think that's a coincidence.

Ember has been an enabler of great productivity for many teams for almost a
decade and I'm sure it's going to continue to be that. It's changed and improved
a lot since its first release and is now in better shape than ever with its
[Octane edition](https://emberjs.com/editions/octane/). All those changes and
improvements were introduced with minimal effort for teams to stay up to date
and migrate their apps in small steps over time. There also is little to no
fragmentation within the community â€“ everyone using Ember.js is basing their
work on the same idioms and techniques coming from a highly cohesive ecosystem.
And when more changes and improvements are to come in the future, they will be
battle-tested before migrating the community and that migration will take
everyone along, leaving no app behind.

[Qonto](https://qonto.com) and [Clark](http://clark.de) are two great examples
of teams executing on their product vision steadily and sustainably. The
companies are two of the most successful and fastest growing FinTechs in Europe
and have grown their teams significantly over the past few years while
continuing to ship steadily and sustainably. But they are not the only ones
using Ember successfully of course â€“ others include companies building ambitious
apps with large and growing teams like LinkedIn, Apple, Square, Heroku, Intercom
and many more. All those teams might generate little fuzz and hype but ship
product value constantly and will continue to do so building on Ember which will
keep lifting them to new heights for the time to come.
