---
title: Bringing the Matrix Open Standard to Elixir
author: 'Niklas Long'
github: niklaslong
twitter: niklas_long
topic: elixir
bio: 'Backend Engineer, author of the Matrix Elixir SDK'
description: 'Niklas Long introduces the Matrix Elixir SDK.'
---

[Matrix](https://matrix.org) is an open-source, end-to-end encrypted, real-time,
open standard communication protocol designed to protect people's privacy. The
technology has applications not only in messaging and VoIP but similarly in IoT
and AR/VR.

<!--break-->

Introduced in 2014, Matrix is backed by [Element](https://element.io/about)
(formerly New Vector), the company behind the
[Element Matrix client](https://element.io/) (formerly Riot). Adopters include
the
[French government](https://matrix.org/blog/2018/04/26/matrix-and-riot-confirmed-as-the-basis-for-frances-secure-instant-messenger-app),
the US government, [Mozilla](https://wiki.mozilla.org/Matrix),
[Purism](https://matrix.org/blog/2017/08/24/the-librem-5-from-purism-a-matrix-native-smartphone),
[Germany's Ministry of Defence](https://www.heise.de/newsticker/meldung/Open-Source-Bundeswehr-baut-eigene-verschluesselte-Messenger-App-4623404.html)
and the
[German education system](https://sifted.eu/articles/element-germany-deal/).

In May of this year, I began work on a
[Matrix SDK for Elixir](https://github.com/niklaslong/matrix-elixir-sdk) with
the aim of simplifying the process of Matrix-enabling Elixir applications. It's
early days for the project but if you are interested in contributing (all skill
levels welcome) or using the SDK as a foundation for another project, please let
me know!

## Down the rabbit-hole...

Matrix is structured around the federation of homeservers, that is to say the
continuous synchronisation of event history between the homeservers via the
Server-Server API.

![The Matrix Architecture](/assets/images/posts/2020-08-22-bringing-matrix-to-elixir.md/matrix_architecture.png)

Each user is registered on a single homeserver, ideally hosted by themselves,
and can join rooms to communicate with others. A room is a shared history of
events associated with its members. The history is copied in full on each
member's homeserver and all copies are synchronised in real-time. Fundamentally,
a room is a decentralised data store with no single point of control or failure.

A note on Matrix interoperability: it was designed to exchange data with other
platforms such as WhatsApp, Slack, iMessage, Email, Discord, IRC and many more.
This is known as bridging and makes Matrix an attractive one-stop solution to
interface with these services. As an example, Alice who's on Matrix, could
seemlessly communicate with Bob who's on Freenode and Chris who's on Slack.
Crucially, bridges connect seperate communities and as such represent a workable
migration path from walled garden networks.

## ...and into the Matrix

The Elixir SDK currently wraps part of the Client-Server API; v0.1 was released
to allow interested parties to begin experimenting. The `Client` module, used to
make requests to homeservers, is currently the highest level of abstraction in
the SDK.

As mentioned above, all changes in a room's state are described by events. They
can represent any data, from users joining a room or sending messages, to image
uploads and VoIP call setup. Let's dip our toes into Matrix by creating a guest
account on `matrix.org` and reading events from the `#matrix:matrix.org` room.

```elixir
iex(1)> {:ok, response} = Client.register_guest("https://matrix.org")
{:ok,
 %Tesla.Env{
   body: %{
     "access_token" => "MDAxOGxvY2F0aW9",
     "device_id" => "guest_device",
     "home_server" => "matrix.org",
     "user_id" => "@56439195154:matrix.org"
   },
   method: :post,
   status: 200,
   url: "https://matrix.org/_matrix/client/r0/register?kind=guest"
 }}
```

The `Client.register_guest/1` call registers a guest user with the Matrix
homeserver and returns an access token (I have shortened for brevity). This
token can be used to authenticate most Matrix endpoints: some don't require
authentication at all. Likewise, standard user accounts, not covered here, use
tokens as authentication once a login flow has been completed.

Naming for all user accounts follow the convention of `@name:server.url`. For
guest accounts, the name is a number generated by the server, e.g., `user_id`
above.

```elixir
iex(2)> token = response.body["access_token"]
"MDAxOGxvY2F0aW9"
```

Once we have an access token, we can attempt to join a room allowing guest
access. One such room is `#matrix:matrix.org`.

```elixir
iex(3)> Client.join_room("https://matrix.org", token, "#matrix:matrix.org")
{:ok,
 %Tesla.Env{
   body: %{
     "consent_uri" => "https://matrix-client.matrix.org/_matrix/consent?u=56440018645&h=c319be84a25b",
     "errcode" => "M_CONSENT_NOT_GIVEN",
     "error" => # please accept terms and conditions
   },
   method: :post,
   status: 403,
   url: "https://matrix.org/_matrix/client/r0/join/%23matrix%3Amatrix.org"
 }}
```

Our call to `Client.join_room/3` returned a `403` and a link to accept the
Matrix terms and conditions. Let's open the link in a browser, read and accept
the terms (if we agree with them), and give it another go.

```elixir
iex(4)> Client.join_room("https://matrix.org", token, "#matrix:matrix.org")
{:ok,
 %Tesla.Env{
   body: %{"room_id" => "!OGEhHVWSdvArJzumhm:matrix.org"},
   method: :post,
   status: 200,
   url: "https://matrix.org/_matrix/client/r0/join/%23matrix%3Amatrix.org"
 }}
```

The call returns a `200` and the `room_id`. You may have noticed this isn't the
same as `#matrix:matrix.org` used to make the request. The latter is an alias.
They allows users to refer to rooms more conveniently instead of using long IDs
such as `!OGEhHVWSdvArJzumhm:matrix.org`. Both are valid, however, and can be
used interchangeably with most endpoints.

The next step is to read events from the homeserver. This can be achieved with a
call to `Client.sync/2`.

```elixir
iex(5)> {:ok, sync_response} = Client.sync("https://matrix.org", token)
# huuuuuuuuuge response
```

Syncing is complex and I won't be going into any great detail here. At a high
level, all events from a user's joined rooms will be included in the response.
These are categorised in the payload.

```elixir
iex(6)> sync_response.body["rooms"]["join"]["!OGEhHVWSdvArJzumhm:matrix.org"]
%{
  "ephemeral" => %{
    "events" => [...] # read-receipts, ...
  },
  "state" => %{
    "events" => [...] # messages, ...
  },
  "timeline" => %{
    "events" => [...], # everything together in a timeline
    "limited" => true,
    "prev_batch" => "t74742-1449340357_757284957"
  }
}
```

In essence, the response is a linear event history for a user. Pagination is
handled by way of pagination tokens like `prev_batch` and can be leveraged in
subsequent `sync` calls.

This is where I'll end this short introduction, however, please check the
[documentation](https://hexdocs.pm/matrix_sdk/) for more information on the
currently implemented endpoints.

## What's next?

Work continues on the SDK, there are a number of endpoints waiting to be
implemented and decisions to be made in how to handle state. Soon, I'm hoping to
release the first version of the
[Elixir/Erlang bindings](https://github.com/niklaslong/olm-elixir) to the
[Olm](https://gitlab.matrix.org/matrix-org/olm) cryptography library maintained
by the Matrix core team. Olm is an implementation of the
[Double Ratchet Algorithm](https://signal.org/docs/specifications/doubleratchet)
written in C/C++ and exposed as a C API. The bindings are a first step towards
implementing end-to-end encryption in the SDK.

The long-term goal is to provide all the tools necessary to build Matrix-enabled
applications in Elixir, from clients to homeservers. Matrix is experimenting
with P2P by bundling clients and homeservers together on the user's device. This
could lead to interesting implementations in Elixir, potentially targeting
WebAssembly thanks to [Lumen](https://github.com/lumen/lumen).

It is my belief Elixir can be a powerful tool in decentralising the web.
Projects like Matrix are vitally important, I hope the SDK will encourage
creators to start projects in this problem space.
