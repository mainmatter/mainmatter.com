---
title: Bringing Matrix to Elixir
author: 'Niklas Long'
github: niklaslong
twitter: niklas_long
topic: elixir
bio: 'Backend Engineer, author of the Matrix Elixir SDK'
description: 'Niklas Long introduces the Matrix Elixir SDK.'
---

[Matrix](https://matrix.org) is an open-source, end-to-end encrypted, real-time,
open standard communication protocol designed to protect people's privacy. The
technology has applications not only in messaging and VoIP but similarly in IoT
and AR/VR.

<!--break-->

Introduced in 2014, Matrix is backed by [Element](https://element.io/about)
(formerly New Vector), the company behind the
[Element Matrix client](https://element.io/) (formerly Riot). Adopters include
the
[French government](https://matrix.org/blog/2018/04/26/matrix-and-riot-confirmed-as-the-basis-for-frances-secure-instant-messenger-app),
the US government, [Mozilla](https://wiki.mozilla.org/Matrix),
[Purism](https://matrix.org/blog/2017/08/24/the-librem-5-from-purism-a-matrix-native-smartphone),
[Germany's Ministry of Defence](https://www.heise.de/newsticker/meldung/Open-Source-Bundeswehr-baut-eigene-verschluesselte-Messenger-App-4623404.html)
and the
[German education system](https://sifted.eu/articles/element-germany-deal/).

In May of this year, I began work on a
[Matrix SDK for Elixir](https://github.com/niklaslong/matrix-elixir-sdk) with
the aim of simplifying the process of Matrix-enabling Elixir applications. It's
early days for the project but if you are interested in contributing (all skill
levels welcome) or using the SDK as a foundation for another project,
please [let me know](https://twitter.com/niklas_long)! Included at the end of
this post, is a section describing the project's status.

### Down the rabbit-hole and into the Matrix

Matrix is structured around the __federation__ of __homeservers__, that is to say
the continuous synchronisation of __event__ history between the homeservers via
the __Server-Server API__.

![The Matrix Architecture](/assets/images/posts/2020-08-22-bringing-matrix-to-elixir.md/matrix_architecture.png)

Each user is registered on a single homeserver, ideally hosted by themselves,
and can join __rooms__ to communicate with others. A room is a shared history of
events associated with its members. The history is copied in full on each
member's homeserver and all copies are synchronised in real-time. Fundamentally,
a room is a decentralised data store with no single point of control or failure.

All changes in a room's state are described by events. They can represent any
data, from users joining a room or sending messages, to image uploads and VoIP
call setup.

Let's dip our toes into Matrix by creating a guest account on `matrix.org` and
reading events from the `#matrix:matrix.org` room using the SDK.

```elixir
iex(1)> {:ok, response} = Client.register_guest("https://matrix.org")
{:ok,
 %Tesla.Env{
   body: %{
     "access_token" => "MDAxOGxvY2F0aW9",
     "device_id" => "guest_device",
     "home_server" => "matrix.org",
     "user_id" => "@56439195154:matrix.org"
   },
   method: :post,
   status: 200,
   url: "https://matrix.org/_matrix/client/r0/register?kind=guest"
 }}
```

The `Client.register_guest/1` call registers a guest user with the Matrix
homeserver and returns an access token (I have shortened for brevity). This
token can be used to authenticate most Matrix endpoints: some don't require
authentication at all. Likewise, standard user accounts, not covered here, use
tokens as authentication once a __login flow__ has been completed.

Naming for all user accounts follow the convention of `@name:server.url`. For
guest accounts, the __name__ is a number generated by the server, e.g., `user_id`
above.

```elixir
iex(2)> token = response.body["access_token"]
"MDAxOGxvY2F0aW9"
```

Once we have an access token, we can attempt to join a room allowing guest
access. One such room is `#matrix:matrix.org`.

```elixir
iex(3)> Client.join_room("https://matrix.org", token, "#matrix:matrix.org")
{:ok,
 %Tesla.Env{
   body: %{
     "consent_uri" => "https://matrix-client.matrix.org/_matrix/consent?",
     "errcode" => "M_CONSENT_NOT_GIVEN",
     "error" => # please accept terms and conditions
   },
   method: :post,
   status: 403,
   url: "https://matrix.org/_matrix/client/r0/join/%23matrix%3Amatrix.org"
 }}
```

Our call to `Client.join_room/3` returned a `403` and a link to accept the
Matrix terms and conditions. Let's open the link in a browser, read and accept
the terms (if we agree with them), and give it another go.

```elixir
iex(4)> Client.join_room("https://matrix.org", token, "#matrix:matrix.org")
{:ok,
 %Tesla.Env{
   body: %{"room_id" => "!OGEhHVWSdvArJzumhm:matrix.org"},
   method: :post,
   status: 200,
   url: "https://matrix.org/_matrix/client/r0/join/%23matrix%3Amatrix.org"
 }}
```

The call returns a `200` and the `room_id`. You may have noticed this isn't the
same as `#matrix:matrix.org` used to make the request. The latter is an __alias__.
They allows users to refer to rooms more conveniently instead of using long
IDs such as `!OGEhHVWSdvArJzumhm:matrix.org`. Both are valid, however, and can
be used interchangeably with most endpoints.

The next step is to read events from the homeserver. This can be achieved with a
call to `Client.sync/2`.

```elixir
iex(5)> {:ok, sync_response} = Client.sync("https://matrix.org", token)
# Huuuuuuuuuge response
```

Syncing is complex and I won't be going into any great detail here. At a high
level, all events from a user's joined rooms will be included in the response.
These are categorised in the payload.

```elixir
iex(6)> sync_response.body["rooms"]["join"]["!OGEhHVWSdvArJzumhm:matrix.org"]
%{
  "ephemeral" => %{
    "events" => [...] # read-receipts, ...
  },
  "state" => %{
    "events" => [...] # messages, ...
  },
  "timeline" => %{
    "events" => [...], # everything together in a timeline.
    "limited" => true,
    "prev_batch" => "t74742-1449340357_757284957"
  }
}
```

Fundamentally, the response is a linear event history for a user. Pagination is
handled by way of pagination tokens like `prev_batch` and can be leveraged in
subsequent `sync` calls.

### Project status

The SDK currently wraps part of the __Client-Server API__. There is work to be
done in adding the missing endpoints; v0.1 was released to allow interested
parties to begin experimenting with Matrix in Elixir. In parallel, I'm working on the
[Elixir/Erlang bindings](https://github.com/niklaslong/olm-ex) to the
[Olm](https://gitlab.matrix.org/matrix-org/olm) cryptography library maintained
by the Matrix core team, by leveraging C NIFs. Lastly, there's an
[experimental Elixir client](https://github.com/niklaslong/matrix-client) in the
works, providing usage feedback for the SDK. In future, I expect to include
tools to manage state, both for encryption and user sessions in the SDK.

The long-term objective is to provide all the tools necessary to build Matrix-enabled
applications in Elixir, from clients to homeservers. Matrix is experimenting
with P2P by bundling clients and homeservers together on the user's device. This
could lead to interesting implementations in Elixir, potentially targeting
WebAssembly thanks to [Lumen](https://github.com/lumen/lumen).

It is my belief Elixir can be a powerful tool in decentralising the web.
Projects like Matrix are vitally important, I hope the SDK helps a little in
encouraging creators to start projects in this problem space.
