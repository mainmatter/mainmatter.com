---
title: "Keeping Artifact Sizes Under Control"
authorHandle: oscard0m_
tags: [gravity, testing, process, mainmatter]
bio: "Oscar Dominguez, Software Engineer"
description: "Staying on top of asset sizes can be challenging. Gravity is a developer tool taht helps teams catch regressions early."
og:
  image: /assets/images/posts/2025-03-19-gravity/og-image.jpg
image: "/assets/images/posts/2025-03-19-gravity/man-falling-darker-gray-logo.webp"
imageAlt: "Gravity logo and backgound."
tagline: <p>Staying on top of asset sizes can be challenging, but keeping them in check can make a big difference.</p>
---

It's surprisingly easy to inflate your build artifacts without noticing. Perhaps you added a simple date formatter and included `moment.js`, inadvertently adding hundreds of kilobytes to your JavaScript bundle. Or you shipped a 16MB JPEG to your website where a small thumbnail weighing in at a few KB would have be sufficient. Maybe a new dependency in your Rust project increased your CLI tool's size by several megabytes for very little added value. These small changes accumulate, impacting performance, user experience, and leading to unnecessary computation or data transfer and storage costs.

We've seen this over and over across the [numerous projects](/work/) we worked on over the years. Innocuous code changes can significantly increase artifact sizes, often going unnoticed because there's no way to see these implications during a pull request review. That's why we created [Gravity](https://gravity.ci), a tool that visualizes a PR's impact on artifact sizes within the CI pipeline. It supports all kinds of artifacts, from JS bundles and images to binaries and Docker imagesâ€“anything where your care about the size of your artifacts."

## How does Gravity work?

Inspired by visual regression testing tools like [Percy](https://percy.io/) and [Chromatic](https://www.chromatic.com/), Gravity integrates seamlessly into the developer workflow:

1. Gravity analyzes production build artifacts for every CI run.
2. For each new pull request, Gravity compares the artifacts generated by the PR against those from the target branch. If it detects new or growing artifacts, it adds a failing check to the PR, preventing it from being merged.
3. The developer reviews the changes in Gravity. If the changes are intentional and appropriate, they approve them. Otherwise, they address the issues.
4. Once all changes are approved, the Gravity check turns green, and the PR is ready to merge.

Here's a brief video of Gravity in action:

TODO: add video

## How Does Gravity Work?

Gravity consists of a set of core components:

- the CLI tool [`@gravityci/cli`](https://www.npmjs.com/package/@gravityci/cli), which runs in your CI environment
- The Gravity server, which processes uploaded artifacts, calculates differences, and hosts the UI for developers to review and approve changes.
- the GitHub[^1], which enables Gravity to interact with the repository, such as adding checks to pull requests.

The execution flow is roughly as follows:

{# sequenceDiagram GitHub->>+CI System: push triggers CI run CI System->>+CI System: build production artifacts CI System->>+S3: upload production artifacts CI System->>+Gravity Server: trigger analysis Gravity Server->>+S3: retrieve artifacts Gravity Server->>+Gravity Server: analyze artifacts alt uploaded artifacts are for PR Gravity Server->>+Gravity Server: compare artifacts to <br/>those for PR target branch Gravity Server->>+Gravity GitHub App: add check to PR Gravity GitHub App->>+GitHub: add check Note left of Gravity GitHub App: failing check if new or growing<br/> assets, succsessful otherwise Gravity Server->>+Gravity Server: developer reviews <br/>and approves changes Gravity Server->>+Gravity GitHub App: update check on PR Gravity GitHub App->>+GitHub: update check Note left of Gravity GitHub App: mark check successful<br/>if changes are approved end #} ![Gravity Diagram](/assets/images/posts/2025-03-19-gravity/gravity-diagram.svg)

### 1. Artifact Upload

Each time CI runs, Gravity's CLI uploads the artifacts to [S3](https://aws.amazon.com/s3/). You can upload entire folders or individual files:

```
npx @gravityci/cli dist/ a-specifix-file.bin
```

Typically, you should use artifacts from a production build with all optimizations applied, ensuring Gravity analyzes the same files that ultimately reach your users.

### 2. Artifact Analysis

Once the artifacts are uploaded, Gravity's CLI triggers their analysis. The Gravity server retrieves the artifacts from S3, analyzes them, and stores the results. If the CI run was not initiated by a pull request, the process concludes hereâ€”Gravity has analyzed the artifacts and stored the results for future use. This scenario typically applies to CI runs for a project's default branch, such as `main`. If the CI run was triggered by a PR, the process continues as described in the next step.

#### Rust and NAPI-RS

To ensure efficient and reliable analysis of uploaded artifacts at scale, we implemented the analyzer in [Rust](/rust-consulting/) and integrated it into the JS codebase using [NAPI-RS](https://napi.rs). Initially, this part of the system was also implemented in JavaScript, but we encountered stability and resource issues. Switching to Rust significantly improved performance and reliability.

### 3. Analysis Comparison

If the uploaded artifacts belong to a GitHub pull request, the Gravity server compares the analysis results with those of the PR's target commit. If there are no new artifacts and none have increased in size (i.e., no changes or only artifacts that have shrunk), Gravity adds a successful [_GitHub status check_](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/collaborating-on-repositories-with-code-quality-features/about-status-checks) to the pull request, automatically approving the changes:

![Screenshot of Gravity Check in GitHub: Automatically approved](/assets/images/posts/2025-03-19-gravity/automatically-approved.png)

To interact with GitHub API, we use Octokit (where [I'm a regular contributor](https://github.com/orgs/octokit/people?query=oscard0m) ðŸ™Œ).

If new artifacts are detected or existing ones have grown in size, a failing status check is added:

![Screenshot of Gravity Check in GitHub: It needs approval](/assets/images/posts/2025-03-19-gravity/needs-approval.png)

These changes require manual review and approval by the developer to ensure they are intentional and appropriate.

### 4. Review and Approval

Developers can review artifact size changes in Gravity's dashboard, a [Remix](https://remix.run) app that displays which files have changed and by how much.

![Approval page](/assets/images/posts/2025-03-19-gravity/approval-page.mp4#video)

If the developer approves the difference, Gravity updates the status check in GitHub, allowing the pull request to proceed to merge:

![Screenshot of Gravity Check in GitHub: Approved](/assets/images/posts/2025-03-19-gravity/approved.png)

## Future Plans

Currently, Gravity supports public GitHub repositories only. We plan to expand support to additional code hosting platforms and CI environments in the future. Also, the system would allow for more advanced analyses beyond just file sizes, such as:

- inspecting uploaded artifacts for deeper insights
- adding charts to track artifact sizes over time
- displaying the actual diffs that cause size changes

We'd love to hear your ideas for Gravityâ€”[feel free to share your thoughts](/contact/)!

[^1]: Currently, Gravity supports GitHub and GitHub Actions only but we plan to add support for more code hosting platforms and CI environments in the future.
