---
title: "Introducing Gravity: An Easier Way to Keep Build Artifact Sizes Under Control"
authorHandle: oscard0m_
tags: [gravity, ci, bundlesize, performance]
bio: "Oscar Dominguez, Software Engineer"
description: "Gravity monitors build artifact sizes to prevent accidental increases – right in your CI pipeline."
og:
  image: /assets/images/posts/2025-03-19-gravity/og-image.jpg
image: "/assets/images/posts/2025-03-19-gravity/man-falling-darker-gray-logo.webp"
imageAlt: "Gravity logo and backgound."
---

Build artifact sizes might not be the first thing you think about during code reviews, but keeping them in check can make a big difference.

It’s easy to bloat your build without realizing it. Maybe you just needed a simple date formatter and pulled in `moment.js`, unknowingly adding hundreds of kilobytes of JavaScript. Or you accidentally shipped a 16MB 8000×8000 pixel JPEG. Or maybe you added `serde_json` to a Rust project just to parse a tiny config file, only to see your binary size jump by megabytes. These small choices add up, and if they go unnoticed, they can hurt performance, user experience, and maintainability.

At [Mainmatter](https://mainmatter.com), we've seen firsthand how even small changes can **unintentionally** lead to surprising performance regressions. That's why we built [Gravity](https://gravity.ci), a tool that helps developers easily **visualize** and **review** build artifact sizes directly within their CI/CD pipeline. Today, we're excited to share it with the world.

## What is Gravity?

Gravity is a tool that helps developers manage build artifact sizes directly within their CI/CD pipeline. It monitors all types of artifacts, including binaries, JavaScript bundles, images, CSS files, and more, by comparing changes in pull requests.

Inspired by visual regression testing tools like [Percy](https://percy.io/) and [Chromatic](https://www.chromatic.com/), Gravity catches _undesired artifact size changes_ (instead of undesired _visual changes_) by:

1. Establishing a workflow where the developer gets visibility of the implications of their changes in terms of artifact size
2. Enforcing to review these size changes

When artifact sizes increase, Gravity flags them, providing reviewers with a clear overview to assess whether the change is expected or needs further attention. This process streamlines code reviews, reduces the risk of human error, and helps maintain the quality and performance of your projects—whether you're building applications, libraries, or tools.

## Why Use Gravity?

☑️ **Improve review quality**

Someone added an image and forgot to compress it? A new dependency but the library is bloated? Some CSS isn't properly minimized? See exactly which files have changed in size in your artifact. Gravity gives you a clear overview right where you need it—in your pull request.

☑️ **Maintain performance**

Identify accidental size increases early on, and catch potential performance issues before they reach production.

☑️ **Save time**

Avoid wasting time backtracking through commits. Gravity highlights size changes automatically, making code reviews faster and easier.

## How Does Gravity Work?

Gravity integrates directly into your CI/CD pipeline by combining a GitHub app, a CLI tool in your GitHub Actions, and a robust server-side analysis process. Once set up, Gravity automatically triggers an analysis every time a pull request is opened or modified. Here's a closer look at how it works:

![Gravity Diagram](/assets/images/posts/2025-03-19-gravity/gravity-diagram.svg)

### 1. Artifact Upload

Every time CI runs, Gravity's CLI tool collects the build artifacts and uploads them to [S3](https://aws.amazon.com/s3/), and calls Gravity's server to schedule an analysis, adding you to a queue ([Redis](https://redis.io/)).

It is expected your GitHub Action to run all the build and optimization steps to generate the definitive artifact you want to measure **before** the Gravity CLI runs. If the artifact is not available, Gravity CLI can't upload anything.

### 2. Server-Side Analysis

When the upload is ready, the analysis starts, comparing the artifact sizes associated to the last commit of your pull request's _head branch_ with those in _base branch_. Gravity does **not** inspect the content of the files, focusing purely on size changes to maintain data privacy and security.

### 3. Real-Time Feedback in GitHub

Once the analysis is finished, Gravity updates the [_GitHub status check_](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/collaborating-on-repositories-with-code-quality-features/about-status-checks) directly within the pull request.

**3.1.** If the artifact size has not increased, the status check is automatically approved, and the pull request can be merged without additional steps.

![Screenshot of Gravity Check in GitHub: Automatically approved](/assets/images/posts/2025-03-19-gravity/automatically-approved.png)

**3.2.** If Gravity detects a size increase, the status check will fail. Reviewers are prompted to access the Gravity Dashboard, where they can see a detailed breakdown of which files increased in size and by how much.

![Screenshot of Gravity Check in GitHub: It needs approval](/assets/images/posts/2025-03-19-gravity/needs-approval.png)

![Approval page](/assets/images/posts/2025-03-19-gravity/approval-page.mp4#video)

If the reviewer deems the size increase acceptable, they can approve the change directly in the Gravity Dashboard. This approval updates the status check in GitHub, allowing the pull request to proceed to merge.

![Screenshot of Gravity Check in GitHub: Approved](/assets/images/posts/2025-03-19-gravity/approved.png)

<p style="color:red">[INSERT VIDEO HERE]<p>

## How we built Gravity?

Gravity is a monorepo with multiple packages which end up configuring all the Gravity System. The main pieces are:

- Gravity CLI
- Gravity server
- Gravity pipeline
- Gravity dashboard

### Gravity CLI

_Gravity CLI_ is the command line tool you install in your GitHub Action. This piece is responsible of:

- Upload the artifact to _AWS S3_
- Send a request to the _Gravity server_ to store the corresponding build to the Data Base and schedule an analysis.

It is built with _TypeScript_. We opted to use [meow](https://github.com/sindresorhus/meow) as our CLI helper.

### Gravity server

_Gravity server_ is a _Express.js_ application written in _TypeScript_. The main functionalities it has are:

- To provide single-use URLs to upload files to Gravity's _AWS S3_ bucket.
- Manage the creation of a _build_ and store it in Gravity's DB (_PostgreSQL_)
- Connect with Gravity Worker to schedule an analysis
- Interact with GitHub API to update the status check to _pending_

The choice to interact with Gravity's Data Base (_PostgreSQL_) is _TypeORM_. To interact with GitHub API, we use Octokit (where [I'm a regular contributor](https://github.com/orgs/octokit/people?query=oscard0m)) to interact with GitHub API.

### Gravity pipeline

_Gravity pipeline_ is the project in charge of managing the different artifact analysis requested by different PR's. In order to scale, we use a queue system to support peaks of traffic in _Gravity System_. To accomplish this we use Redis and we manage it with [`BullMQ`](https://docs.bullmq.io/).

The key piece of the project? **Gravity Analyzer**, a piece written in _Rust_ to get the best performance. We initially had all the logic to download the artifacts from _S3_ and compare sizes file per file in _JavaScript_ but, at certain scale, in projects where there are hundreds of files to compare, it become a need to optimize this process. The switch to Rust made the analysis much faster, and we used [napi-rs](https://napi.rs/) to bridge the gap between _Rust_ and _TypeScript_.

### Gravity dashboard

_Gravity dashboard_ is the web app, built with [Remix](https://remix.run/). It's where you log in, see your projects, compare pull request results and manage approvals. The dashboard interacts with Gravity's database and GitHub API, giving you the possibility to approve PR checks with just a click.
