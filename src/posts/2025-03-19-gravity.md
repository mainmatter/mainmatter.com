---
title: "Introducing Gravity: An Easier Way to Keep Build Artifact Sizes Under Control"
authorHandle: oscard0m_
tags: [gravity, ci, bundlesize, performance]
bio: "Oscar Dominguez, Software Engineer"
description: "Gravity monitors build artifact sizes to prevent accidental increases – right in your CI pipeline."
og:
  image: /assets/images/posts/2025-03-19-gravity/og-image.jpg
image: "/assets/images/posts/2025-03-19-gravity/man-falling-darker-gray-logo.webp"
imageAlt: "Gravity logo and backgound."
---

Build artifact sizes might not be the first thing you think about during code reviews, but keeping them in check can make a big difference.

It's easy to add a JS dependency for a tiny feature that adds megabytes to the JS bundle without noticing or adding a huge _16MB_ _8000x8000_ pixel JPEG to a website or even adding a dependency to a Rust crate that results in a huge increase of the released binary. Any minor update can easily lead to an unexpected size increase, and if it goes unnoticed, it could cause issues down the line.

At [Mainmatter](https://mainmatter.com), we've seen firsthand how even small changes can **unintentionally** lead to surprising performance regressions. That's why we built [Gravity](https://gravity.ci), a tool that helps developers easily **visualize** and **review** build artifact sizes directly within their CI/CD pipeline. Today, we're excited to share it with the world.

## What is Gravity?

Gravity is a tool that helps developers manage build artifact sizes directly within their CI/CD pipeline. It monitors all types of artifacts, including binaries, JavaScript bundles, images, CSS files, and more, by comparing changes in pull requests.

Inspired by visual regression testing tools like [Percy](https://percy.io/) and [Chromatic](https://www.chromatic.com/), Gravity catches _undesired artifact size changes_ (instead of undesired _visual changes_) by:

1. Establishing a workflow where the developer gets visibility of the implications of their changes in terms of artifact size
2. Enforcing to review these size changes

When artifact sizes increase, Gravity flags them, providing reviewers with a clear overview to assess whether the change is expected or needs further attention. This process streamlines code reviews, reduces the risk of human error, and helps maintain the quality and performance of your projects—whether you're building applications, libraries, or tools.

## Why Use Gravity?

☑️ **Improve review quality**

See exactly which files have changed in size. Gravity gives you a clear overview right where you need it—in your pull request.

☑️ **Maintain performance**

Identify accidental size increases early on, and catch potential performance issues before they reach production.

☑️ **Save time**

Avoid wasting time backtracking through commits. Gravity highlights size changes automatically, making code reviews faster and easier.

## How Does Gravity Work?

Gravity integrates directly into your CI/CD pipeline by combining a GitHub app, a CLI tool in your GitHub Actions, and a robust server-side analysis process. Once set up, Gravity automatically triggers an analysis every time a pull request is opened or modified. Here's a closer look at how it works:

### 1. Artifact Upload

When there are changes in a pull request, Gravity's CLI tool collects the build artifacts and uploads them to [S3](https://aws.amazon.com/s3/), and calls Gravity's server to schedule an analysis, adding you to a queue ([Redis](https://redis.io/)).

### 2. Server-Side Analysis

When it’s your turn in the queue, the analysis starts, comparing the artifact sizes in the pull request with those in the [_default branch_](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-branches#about-the-default-branch). Gravity does **not** inspect the content of the files, focusing purely on size changes to maintain data privacy and security.

### 3. Real-Time Feedback in GitHub

Once the analysis is finished, Gravity updates the [_GitHub status check_](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/collaborating-on-repositories-with-code-quality-features/about-status-checks) directly within the pull request.

**3.1.** If the artifact size has not increased, the status check is automatically approved, and the pull request can be merged without additional steps.

![Screenshot of Gravity Check in GitHub: Automatically approved](/assets/images/posts/2025-03-19-gravity/automatically-approved.png)

**3.2.** If Gravity detects a size increase, the status check will fail. Reviewers are prompted to access the Gravity Dashboard, where they can see a detailed breakdown of which files increased in size and by how much.

![Screenshot of Gravity Check in GitHub: It needs approval](/assets/images/posts/2025-03-19-gravity/needs-approval.png)

![Approval page](/assets/images/posts/2025-03-19-gravity/approval-page.mp4#video)

If the reviewer deems the size increase acceptable, they can approve the change directly in the Gravity Dashboard. This approval updates the status check in GitHub, allowing the pull request to proceed to merge.

![Screenshot of Gravity Check in GitHub: Approved](/assets/images/posts/2025-03-19-gravity/approved.png)

<p style="color:red">[INSERT VIDEO HERE]<p>

## How we built Gravity?

Gravity is a monorepo with multiple packages which end up configuring all the Gravity System. The main pieces are:

- Gravity CLI
- Gravity server
- Gravity pipeline
- Gravity dashboard

### Gravity CLI

_Gravity CLI_ is the command line tool you install in your GitHub Action. This piece is responsible of:

- Upload the artifact to _AWS S3_
- Send a request to the _Gravity server_ to store the corresponding build to the Data Base and schedule an analysis.

It is built with _TypeScript_. We opted to use [meow](https://github.com/sindresorhus/meow) as our CLI helper.

### Gravity server

_Gravity server_ is a _Express.js_ application written in _TypeScript_. The main functionalities it has are:

- To provide single-use URLs to upload files to Gravity's _AWS S3_ bucket.
- Manage the creation of a _build_ and store it in Gravity's DB (_PostgreSQL_)
- Connect with Gravity Worker to schedule an analysis
- Interact with GitHub API to update the status check to _pending_

The choice to interact with Gravity's Data Base (_PostgreSQL_) is _TypeORM_. To interact with GitHub API, we use Octokit (where [I'm a regular contributor](https://github.com/orgs/octokit/people?query=oscard0m)) to interact with GitHub API.

### Gravity pipeline

_Gravity pipeline_ is the project in charge of managing the different artifact analysis requested by different PR's. In order to scale, we use a queue system to support peaks of traffic in _Gravity System_. To accomplish this we use Redis and we manage it with [`BullMQ`](https://docs.bullmq.io/).

The key piece of the project? **Gravity Analyzer**, a piece written in _Rust_ to get the best performance. We initially had all the logic to download the artifacts from _S3_ and compare sizes file per file in _JavaScript_ but, at certain scale, in projects where there are hundreds of files to compare, it become a need to optimize this process. The switch to Rust made the analysis much faster, and we used [napi-rs](https://napi.rs/) to bridge the gap between _Rust_ and _TypeScript_.

### Gravity dashboard

_Gravity dashboard_ is the web app, built with [Remix](https://remix.run/). It's where you log in, see your projects, compare pull request results and manage approvals. The dashboard interacts with Gravity's database and GitHub API, giving you the possibility to approve PR checks with just a click.
